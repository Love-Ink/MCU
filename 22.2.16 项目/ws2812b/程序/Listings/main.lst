C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2022 19:38:55 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Program Files\Keil 5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "STC8G.H"
   2          #include "intrins.h"
   3          #include "BSP_ws2812.h"
   4          
   5          sbit KEY_IN = P5^4;
   6          
   7          #define uchar unsigned char 
   8          
   9          unsigned long pow (int a,int b);
  10          
  11          void Delay10ms();
  12          void Delay2ms();
  13          
  14          void Demo ();
  15          int readPwmTime ();
  16          
  17          uchar KEYBuff=0,KEYBufBack=0;
  18          uchar flag = 1;
  19          uchar x=0,j=0;
  20          bit mode = 0;
  21          unsigned long LEDBuff=0xffffffff;
  22          
  23          int main(void) {
  24   1        uchar i;
  25   1        
  26   1        struct RGB BLACK,RED,GREEN;
  27   1      
  28   1        BLACK.G_VAL = 0x00;  //黑色色彩结构体
  29   1        BLACK.R_VAL = 0x00;
  30   1        BLACK.B_VAL = 0x00;
  31   1      
  32   1        GREEN.G_VAL = 0xFF; //绿色色彩结构体
  33   1        GREEN.R_VAL = 0x00;
  34   1        GREEN.B_VAL = 0x00;
  35   1      
  36   1        RED.G_VAL = 0x00;   //红色色彩结构体
  37   1        RED.R_VAL = 0x5F;
  38   1        RED.B_VAL = 0x00;
  39   1        
  40   1        P5M0 = 0x00;        //配置P5 为输入输出双向模式
  41   1        P5M1 = 0x00;        //配置P5 为输入输出双向模式
  42   1        
  43   1        TMOD = 0x11;        //配置计数器 TR0,TR1为模式1  16位计数器
  44   1        TH0 = 0x0B;         //TR0 高位 初始值
  45   1        TL0 = 0xDC;         //TR0 低位 初始值
  46   1        TH1 = 0x00;         //TR1 高位 初始值
  47   1        TL1 = 0x00;         //TR1 低位 初始值
  48   1        TR0 = 1;
  49   1        ET0 = 1;
  50   1        EA = 1;
  51   1        
  52   1        while(1){
  53   2          Demo();
  54   2          while(i!=32){         //连续对三十二个灯写入数据
C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2022 19:38:55 PAGE 2   

  55   3            if((LEDBuff>>i)&0x01==1){
  56   4              send_24_Bit(RED);
  57   4            }else{
  58   4              send_24_Bit(BLACK);
  59   4            }
  60   3            i++;
  61   3          }
  62   2          i=0;
  63   2          P55 = 0;
  64   2          if (flag!=4){
  65   3            Delay10ms();       //加速堆叠效果
  66   3          }else{
  67   3            Delay2ms();
  68   3          }
  69   2        }
  70   1      }
  71          
  72          void interruptTime0 () interrupt 1{
  73   1        static uchar count25ms = 0;
  74   1        TH0 = 0x0B;
  75   1        TL0 = 0xDC;
  76   1        if(count25ms >= 20){
  77   2          count25ms=0;
  78   2          if(readPwmTime() > 0x0EA6){    //检测PWM信号高电平宽度是否大于 1.5ms
  79   3              KEYBuff = 1;
  80   3          }else {
  81   3              KEYBuff = 0;
  82   3          }
  83   2        }
  84   1        
  85   1        if(KEYBuff != KEYBufBack){
  86   2          mode = !mode;
  87   2          KEYBufBack = KEYBuff;
  88   2        }
  89   1        
  90   1        count25ms++;
  91   1        
  92   1      }
  93          
  94          
  95          
  96          
  97          void Demo (){ // 流水灯位移计算
  98   1        
  99   1        if(mode==1){
 100   2        if(flag == 1){
 101   3            LEDBuff >>= 1;
 102   3            if(LEDBuff == 0x001){
 103   4                flag = 2;
 104   4            }
 105   3        }else if(flag == 2){
 106   3          LEDBuff = ((LEDBuff&0x80000000)>>9)|((LEDBuff<<1)&0xffffffff);
 107   3          if(LEDBuff == 0x80000000)
 108   3            flag = 3;
 109   3        } else if (flag == 3){
 110   3          LEDBuff = ((LEDBuff&0x001)<<9)|((LEDBuff>>1)&0xffffffff);
 111   3          if (LEDBuff == 0x001)
 112   3            flag = 4;
 113   3        }else if(flag == 4) {
 114   3          LEDBuff -= 2147483648/(pow(2,j));
 115   3          j++;
 116   3          if(j == (31-x)){
C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2022 19:38:55 PAGE 3   

 117   4              j = 0;
 118   4              x++;
 119   4            }
 120   3          if(x==31){
 121   4            flag = 5;x=0;}
 122   3        }else if(flag == 5){
 123   3          LEDBuff <<= 1;
 124   3          if((LEDBuff&0xffffffff) == 0x80000000){
 125   4            flag = 6;LEDBuff=0xC0000000;}
 126   3        }else if(flag == 6){
 127   3          LEDBuff >>= 1;
 128   3          LEDBuff += 0x80000000;
 129   3          if((LEDBuff&0xffffffff) == 0xffffffff){
 130   4             flag=1;
 131   4            mode = 0;
 132   4          }
 133   3        }
 134   2        }else{
 135   2          LEDBuff = 0xffffffff;
 136   2          flag = 1;
 137   2          x=0;
 138   2          j = 0;
 139   2        }
 140   1        LEDBuff &= 0xffffffff;
 141   1        
 142   1      }
 143          unsigned long pow (int a,int b){
 144   1        unsigned long pow=a;
 145   1        if(b==0){
 146   2          return 1;
 147   2        } else if (b==1) {
 148   2          return a;
 149   2        }
 150   1        for(;b>1;b--){
 151   2          pow *= a;
 152   2        }
 153   1        return pow;
 154   1      }
 155          
 156          void Delay10ms(){     //10ms延时
 157   1        unsigned char i, j, k;
 158   1      
 159   1        i = 2;
 160   1        j = 134;
 161   1        k = 152;
 162   1        do
 163   1        {
 164   2          do
 165   2          {
 166   3            while (--k);
 167   3          } while (--j);
 168   2        } while (--i);
 169   1      }
 170          
 171          void Delay2ms() {    //2ms延时
 172   1        unsigned char i, j;
 173   1      
 174   1        _nop_();
 175   1        _nop_();
 176   1        i = 78;
 177   1        j = 233;
 178   1        do
C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2022 19:38:55 PAGE 4   

 179   1        {
 180   2          while (--j);
 181   2        } while (--i);
 182   1      }
 183          
 184          int readPwmTime (){
 185   1          int PwmTime;
 186   1            while(KEY_IN == 1);
 187   1            while(KEY_IN == 0);
 188   1            TR1 = 1;
 189   1            while(KEY_IN == 1);
 190   1            TR1 = 0;
 191   1            PwmTime = (TH1 << 8)|TL1;
 192   1            TH1 = 0x00;
 193   1            TL1 = 0x00;
 194   1          return PwmTime;
 195   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    918    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
